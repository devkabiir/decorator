/// Creating a library is required for part generation to work
library decorator_generator.example;

/// Import the decorator package
import 'package:decorator/decorator.dart';
import 'package:logging/logging.dart';

/// Import the generated part
/// this is generated by running `pub run build_runner build`
part 'example.d.dart';

Future<void> main() async {
  print(joinArgs(['First'], arg2: ['Second']));
  print(joinArgs3(['First'], arg2: ['Second']));
  print(await joinArgs4(['First'], arg2: ['Second']));

  /// This will throw automatically before [_joinArgs2]
  /// gets executed
  // print(joinArgs2(['First'], null));
}

const Level myLevel = Level('mylevel', 555);

/// Logger for `decorator_generator.example`
final Logger logger = Logger('decorator_generator.example');

String _example;

@MyLogger('_exampleGetter', myLevel)
String get _exampleGetter => _example;

@MyLogger('_exampleSetter', myLevel)
set _exampleSetter(String value) => _example = value;

HostElement<R> greet<R>(HostElement<R> host) {
  print('Hello $host');

  return host;
}

/// This function joins its args
@MyLogger('_joinArgs', myLevel)
@ArgumentsNotNull()
String _joinArgs(List<String> arg1,
    {List<String> arg2 = const [r'''$Default''', 'Args']}) {
  print('_joingArgs executed');

  return ((arg1 ?? [])..addAll(arg2 ?? [])).join();
}

/// This function also joins its args but doesnt check them against being null
@ArgumentsNotNull()
String _joinArgs2(List<String> arg1, [List<String> arg2]) {
  print('_joinArgs2 executed');

  /// Here arguments are not being null checked
  /// but the [ArgumentsNotNull] decorator will throw even before this code gets
  /// executed
  return (arg1..addAll(arg2)).join();
}

/// This one also joins its args but it is decorated with a [HostWrapper], this
/// is useful when the decorater doesn't require any additional args.
@DecorateWith(greet)
String _joinArgs3(List<String> arg1, {List<String> arg2}) {
  print('_joingArgs3 executed');

  return ((arg1 ?? [])..addAll(arg2 ?? [])).join();
}

/// Another one just for fun
@MyLogger.detached('loggerName')
Future<String> _joinArgs4(List<String> arg1, {List<String> arg2}) async {
  print('_joingArgs4 executed');

  return ((arg1 ?? [])..addAll(arg2 ?? [])).join();
}

/// Decorater that null checks all args
class ArgumentsNotNull extends Decorator implements Wrapper, FunctionDecorator {
  const ArgumentsNotNull() : super(runInRelease: true);

  @override
  HostElement<R> wraps<R>(HostElement<R> host) {
    if (host.args?.isNotEmpty ?? false) {
      for (var arg in host.args.keys) {
        if (host.args[arg] == null) {
          throw ArgumentError.notNull(arg);
        }
      }
    }

    if (host.kwargs?.keys?.isNotEmpty ?? false) {
      for (var kwarg in host.kwargs.keys) {
        if (host.kwargs[kwarg] == null) {
          throw ArgumentError.notNull(kwarg);
        }
      }
    }

    return host;
  }
}

/// Decorater that logs the given host with any args
class MyLogger extends Decorator
    implements Wrapper, FunctionDecorator, PropertyDecorator {
  /// Name of the logger to use
  final String loggerName;

  final Level logLevel;

  /// Wether this is a detached logger
  final bool isDetached;

  /// Uses the given logger [loggerName] for logging at [logLevel]
  const MyLogger(this.loggerName, [this.logLevel = Level.FINEST])
      : isDetached = false;

  /// Uses a detached logger for logging
  const MyLogger.detached(this.loggerName, [this.logLevel = Level.FINEST])
      : isDetached = true;

  @override
  HostElement<R> wraps<R>(HostElement<R> host) {
    final message = '$host was called with '
        '\nargs:${host.args} and \nkwargs:${host.kwargs}';

    if (isDetached) {
      Logger.detached(loggerName).log(logLevel, message);
    } else {
      Logger(loggerName).log(logLevel, message);
    }

    return host;
  }
}
